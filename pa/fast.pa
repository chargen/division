#include <omp.h>
#include <pthread.h>
#include <stdio.h>
#include <math.h>
#include <immintrin.h>
#include "util.h"
#define _USE_MIC
$include "parray.pa"
int main(int argc, char *argv[]) {   _pa_main();   return 0;}
#define THREAD_NUM (59*4)
#define REPEAT (1<<11)  // ideal 1<<11
#define NDIMS 8
#define NITERS (256)    // ideal 256
$var NSIMD(4) 			// ideal 4
#define PERFORM
#define N (128)
$parray {paged double[THREAD_NUM][N]} PAGED
$parray {micmem double[THREAD_NUM][N]} MIC

$subprog div_ab(a, b, c) { // y^8: 64-bit sub: 37.584952 Gflops  32-bit sub: 43.564720 Gflops
						   // y^4:								 32-bit sub: 52.946531 Gflops
    __m512d y, q;  union { __m512i i; __m512d d; } p;
    p.d = b; p.i = _mm512_sub_epi32(MAGIC, p.i);		// p.i = MAGIC - p.i
    y = _mm512_fmsub_pd(p.d, b, ONES);		// y = p.d * x - 1
    q = _mm512_fnmadd_pd(p.d, y, p.d);		// q = - p.d * y + p.d
    y = _mm512_mul_pd(y, y);				// y = y * y
    q = _mm512_fmadd_pd(q, y, q);			// q = q * y + q
//    y = _mm512_mul_pd(y, y);				// y = y * y
//    q = _mm512_fmadd_pd(q, y, q);			// q = q * y + q
    y = _mm512_fmadd_pd(y, y, ONES);				// y = y * y  (y = y * y + 1 is even faster!!)
    q = _mm512_fmadd_pd(q, y, q);			// q = q * y + q
	c = _mm512_mul_pd(a, q);				// q = q * a
}
$end

$var NN(1)

$subprog div_abn(a, b, c){
    $repeat(k, 0, $NN){__m512d y@k@, q@k@;}
	$repeat(k, 0, $NN){ union { __m512i i; __m512d d; } p@k@;}
    $repeat(k, 0, $NN){ p@k@.d = b@k@; }
    $repeat(k, 0, $NN){ p@k@.i = _mm512_sub_epi32(MAGIC, p@k@.i); }		// p.i = MAGIC - p.i
    $repeat(k, 0, $NN){ y@k@ = _mm512_fmsub_pd(p@k@.d, b@k@, ONES);	}	// y = p.d * x - 1
    $repeat(k, 0, $NN){ q@k@ = _mm512_fnmadd_pd(p@k@.d, y@k@, p@k@.d);}	// q = - p.d * y + p.d
    $repeat(k, 0, $NN){ y@k@ = _mm512_mul_pd(y@k@, y@k@);}				// y = y * y
    $repeat(k, 0, $NN){ q@k@ = _mm512_fmadd_pd(q@k@, y@k@, q@k@);}		// q = q * y + q
    $repeat(k, 0, $NN){ y@k@ = _mm512_mul_pd(y@k@, y@k@);}				// y = y * y
    $repeat(k, 0, $NN){ q@k@ = _mm512_fmadd_pd(q@k@, y@k@, q@k@);}		// q = q * y + q
//    $repeat(k, 0, $NN){ y@k@ = _mm512_mul_pd(y@k@, y@k@);}				// y = y * y
//    $repeat(k, 0, $NN){ q@k@ = _mm512_fmadd_pd(q@k@, y@k@, q@k@);}		// q = q * y + q
	$repeat(k, 0, $NN){ c@k@ = _mm512_mul_pd(a@k@, q@k@); }				// q = q * e	
}
$end

// auto-vec 27.269131 Gflops
$subprog RUN() {
#pragma offload target(mic) nocopy(m)
    { _PA_CREATE_TIMER         _PA_TIME_NOW
        #pragma omp parallel num_threads(THREAD_NUM)
        {
#ifdef __MIC__
            int pid = omp_get_thread_num();
            const __m512i MAGIC = _mm512_set1_epi64(0x7fde5f73aabb2400);
            const __m512d ONES = _mm512_set1_pd(1.0);
            $repeat(l,0,$NSIMD) {$repeat(k,0,$NN) {__m512d x@l@@k@=_mm512_set1_pd((double)(pid+@l@+@k@));}}
            for(int i = 0; i < REPEAT*NITERS*NDIMS; i += NDIMS) {
                $repeat(l,0,$NSIMD) {{
					$repeat(k,0,$NN) {__m512d s@k@=ONES, q@k@=x@l@@k@;}
					$div_abn(s, q, x@l@)			// 54.738745 Gflops
//                  x@l@0 = _mm512_div_pd(s0, q0);  // 16.559894 Gflops
//					x@l@0 = _mm512_add_pd(s0, q0);	// 297.547590 Gflops
                }}}
            $repeat(l,0,$NSIMD) {$repeat(k,0,$NN) {m[pid]+=_mm512_reduce_add_pd(x@l@@k@);}}
#endif
        }_PA_TIME_NOW
        printf("%f Gflops\n", 1.0 * $NN * NDIMS * THREAD_NUM * REPEAT * $NSIMD * NITERS / ((double)_PA_TIME_DIFF(1, 2)) / 1e9);
}}
$end

$subprog TEST() {
#pragma offload target(mic) nocopy(m,data)
    {   _PA_CREATE_TIMER      _PA_TIME_NOW
        #pragma omp parallel num_threads(THREAD_NUM)
        {
#ifdef __MIC__
            int pid = omp_get_thread_num();
			m[pid] = 0.0;
            const __m512i MAGIC = _mm512_set1_epi64(0x7fde5f73aabb2400);
            const __m512d ONES = _mm512_set1_pd(1.0);
			double* start = data+pid*128;__m512d r = _mm512_set1_pd(0);
			for(int i = 0; i < N; i+=8){
				__m512d x = _mm512_load_pd(start+i);
				if(0)for(int j = 0; j < N; ++j){
					__m512d t = _mm512_set1_pd(start[j]);
					t = _mm512_sub_pd(x, t);
					t = _mm512_fmadd_pd(t, t, ONES);
//					t = _mm512_div_pd(ONES, t);			// 12.084796 Gflops
					$div_ab(ONES, t, t);				// 20.580960 Gflops
					r = _mm512_add_pd(t, r);
				}
				if(1)for(int j = 0; j < N; j+=2){
					__m512d t = _mm512_set1_pd(start[j]);
					__m512d s = _mm512_set1_pd(start[j+1]);
					t = _mm512_sub_pd(x, t);
					s = _mm512_sub_pd(x, s);
					t = _mm512_fmadd_pd(t, t, ONES);
					s = _mm512_fmadd_pd(s, s, ONES);
//					t = _mm512_div_pd(ONES, t);
//					s = _mm512_div_pd(ONES, s);			// 12.932852 Gflops
					$div_ab2(ONES, t, t, ONES, s, s);	// 28.452275 Gflops 31.429838 Gflops
					r = _mm512_add_pd(t, r);
					r = _mm512_add_pd(s, r);
				}
			}
			m[pid] = _mm512_reduce_add_pd(r);
#endif
        }
        _PA_TIME_NOW
		printf("%e s\n", ((double)_PA_TIME_DIFF(1, 2)));
        printf("%f Gflops\n", 1.0 * THREAD_NUM * N * N / ((double)_PA_TIME_DIFF(1, 2)) / 1e9);
    }
}
$end

#ifdef __MIC__
typedef union { double f[8]; __m512d v; } simd_t;
#endif
$main {
#ifdef PERFORM
    $create PAGED(m), PAGED(data)
    $malloc MIC(m), MIC(data)
    $copy PAGED(m) to MIC(m)
	for(int i = 0; i < N * THREAD_NUM;++i)
		data[i] = (i + 1.0)*100/(N * THREAD_NUM);
	double cpu_result = 0.0;
	for(int pid = 0; pid < THREAD_NUM; ++pid){
		double* start = data+pid*128;
		for(int i=0;i<N;++i){
			for(int j=0;j<N;++j){
				double y = start[i]-start[j];
				cpu_result += 1.0/(1.0+y*y);}}}
    $copy PAGED(data) to MIC(data)
    for(int i = 0; i < 5; ++i) {
//		$TEST()
		$RUN()
    }
    $copy MIC(m) to PAGED(m)
	double ans = 0.0;
	for(int pid = 0; pid < THREAD_NUM; ++pid) ans += m[pid];
	printf("cpu = %.20e\nans = %.20e\n", cpu_result, ans);
    $destroy PAGED(m), PAGED(data), MIC(m), MIC(data)
#else
    $for mic[1]{
#ifdef __MIC__
        const __m512i MAGIC = _mm512_set1_epi64(0x7fde5f73aabb2400);
        const __m512d ONES = _mm512_set1_pd(1.0);
        simd_t x, z, res, res0;
        srand(time(NULL));
        for(int i = 0; i < 8; ++i) {
            x.f[i] = rand() * 1.0 / RAND_MAX + rand();
        	z.f[i] = rand() * 1.0 / RAND_MAX;
        }
        $div_ab(z.v, x.v, res.v);
		res0.v = _mm512_div_pd(z.v, x.v);
        for(int i = 0; i < 8; ++i) {
            printf("z/x = %.20e / %.20e\n", z.f[i], x.f[i]);
            printf("\tz/x res = %.20e\n", res.f[i]);
            printf("\tz/x std = %.20e\n", z.f[i] / x.f[i]);
            printf("\tz/x mic = %.20e\n", res0.f[i]);
        }
#endif
    }
#endif
}

